//! Code Binding Generators for Contract ABIs
//!
//! Generate type-safe client bindings in TypeScript and Rust
//! for null-safety and compile-time type checking.

use super::types::*;
use std::collections::HashSet;

/// TypeScript binding generator
pub struct TypeScriptGenerator {
    indent: String,
}

impl TypeScriptGenerator {
    pub fn new() -> Self {
        Self {
            indent: "  ".to_string(),
        }
    }

    /// Generate complete TypeScript bindings for a contract
    pub fn generate(&self, abi: &ContractABI) -> String {
        let mut output = String::new();

        // Header
        output.push_str("// Auto-generated TypeScript bindings for ");
        output.push_str(&abi.name);
        output.push_str("\n// Generated by Soroban Registry Type Safety Validator\n");
        output.push_str("// DO NOT EDIT - Regenerate with `soroban-registry validate-call --generate-bindings`\n\n");

        // Imports
        output.push_str("import { Address, i128, u128, u64, u32, i64, i32 } from '@stellar/stellar-sdk';\n\n");

        // Generate custom types
        let custom_types = self.collect_custom_types(abi);
        for (name, soroban_type) in &abi.types {
            if custom_types.contains(name) {
                output.push_str(&self.generate_type_definition(name, soroban_type));
                output.push('\n');
            }
        }

        // Generate contract interface
        output.push_str(&self.generate_contract_interface(abi));

        // Generate contract client class
        output.push_str(&self.generate_contract_client(abi));

        output
    }

    /// Collect all custom types referenced in the ABI
    fn collect_custom_types(&self, abi: &ContractABI) -> HashSet<String> {
        let mut types = HashSet::new();
        
        for func in &abi.functions {
            for param in &func.params {
                self.collect_types_recursive(&param.param_type, &mut types);
            }
            self.collect_types_recursive(&func.return_type, &mut types);
        }
        
        types
    }

    fn collect_types_recursive(&self, soroban_type: &SorobanType, types: &mut HashSet<String>) {
        match soroban_type {
            SorobanType::Custom { name } => {
                types.insert(name.clone());
            }
            SorobanType::Struct { name, fields } => {
                types.insert(name.clone());
                for field in fields {
                    self.collect_types_recursive(&field.field_type, types);
                }
            }
            SorobanType::Enum { name, variants } => {
                types.insert(name.clone());
                for variant in variants {
                    if let Some(fields) = &variant.fields {
                        for field in fields {
                            self.collect_types_recursive(&field.field_type, types);
                        }
                    }
                }
            }
            SorobanType::Option { value_type } => {
                self.collect_types_recursive(value_type, types);
            }
            SorobanType::Vec { element_type } => {
                self.collect_types_recursive(element_type, types);
            }
            SorobanType::Map { key_type, value_type } => {
                self.collect_types_recursive(key_type, types);
                self.collect_types_recursive(value_type, types);
            }
            SorobanType::Result { ok_type, err_type } => {
                self.collect_types_recursive(ok_type, types);
                self.collect_types_recursive(err_type, types);
            }
            _ => {}
        }
    }

    /// Generate TypeScript type definition
    fn generate_type_definition(&self, name: &str, soroban_type: &SorobanType) -> String {
        match soroban_type {
            SorobanType::Struct { fields, .. } => {
                let mut output = format!("export interface {} {{\n", name);
                for field in fields {
                    let ts_type = self.soroban_to_ts_type(&field.field_type);
                    if let Some(doc) = &field.doc {
                        output.push_str(&format!("{}/** {} */\n", self.indent, doc));
                    }
                    output.push_str(&format!("{}{}: {};\n", self.indent, field.name, ts_type));
                }
                output.push_str("}\n");
                output
            }
            SorobanType::Enum { variants, .. } => {
                // Generate union type for enum
                let mut output = format!("export type {} = ", name);
                let variant_types: Vec<String> = variants
                    .iter()
                    .map(|v| {
                        if v.fields.is_some() {
                            format!("{{ tag: '{}', value: {}_{} }}", v.name, name, v.name)
                        } else {
                            format!("{{ tag: '{}' }}", v.name)
                        }
                    })
                    .collect();
                output.push_str(&variant_types.join(" | "));
                output.push_str(";\n");

                // Generate variant interfaces if they have fields
                for variant in variants {
                    if let Some(fields) = &variant.fields {
                        output.push_str(&format!(
                            "\nexport interface {}_{} {{\n",
                            name, variant.name
                        ));
                        for field in fields {
                            let ts_type = self.soroban_to_ts_type(&field.field_type);
                            output.push_str(&format!("{}{}: {};\n", self.indent, field.name, ts_type));
                        }
                        output.push_str("}\n");
                    }
                }
                output
            }
            _ => format!("export type {} = {};\n", name, self.soroban_to_ts_type(soroban_type)),
        }
    }

    /// Generate contract interface
    fn generate_contract_interface(&self, abi: &ContractABI) -> String {
        let mut output = format!("export interface I{} {{\n", abi.name);

        for func in &abi.functions {
            if func.visibility != FunctionVisibility::Public {
                continue;
            }

            // JSDoc
            if let Some(doc) = &func.doc {
                output.push_str(&format!("{}/**\n", self.indent));
                output.push_str(&format!("{} * {}\n", self.indent, doc));
                for param in &func.params {
                    if let Some(param_doc) = &param.doc {
                        output.push_str(&format!(
                            "{} * @param {} - {}\n",
                            self.indent, param.name, param_doc
                        ));
                    }
                }
                output.push_str(&format!("{} */\n", self.indent));
            }

            // Method signature
            let params: Vec<String> = func
                .params
                .iter()
                .map(|p| format!("{}: {}", p.name, self.soroban_to_ts_type(&p.param_type)))
                .collect();

            let return_type = self.soroban_to_ts_type(&func.return_type);

            output.push_str(&format!(
                "{}{}({}): Promise<{}>;\n",
                self.indent,
                func.name,
                params.join(", "),
                return_type
            ));
        }

        output.push_str("}\n\n");
        output
    }

    /// Generate contract client class
    fn generate_contract_client(&self, abi: &ContractABI) -> String {
        let mut output = format!(
            "export class {}Client implements I{} {{\n",
            abi.name, abi.name
        );

        // Constructor
        output.push_str(&format!(
            "{}private contractId: string;\n",
            self.indent
        ));
        output.push_str(&format!(
            "{}private rpcUrl: string;\n\n",
            self.indent
        ));
        output.push_str(&format!(
            "{}constructor(contractId: string, rpcUrl: string) {{\n",
            self.indent
        ));
        output.push_str(&format!(
            "{}{}this.contractId = contractId;\n",
            self.indent, self.indent
        ));
        output.push_str(&format!(
            "{}{}this.rpcUrl = rpcUrl;\n",
            self.indent, self.indent
        ));
        output.push_str(&format!("{}}}\n\n", self.indent));

        // Methods
        for func in &abi.functions {
            if func.visibility != FunctionVisibility::Public {
                continue;
            }

            let params: Vec<String> = func
                .params
                .iter()
                .map(|p| format!("{}: {}", p.name, self.soroban_to_ts_type(&p.param_type)))
                .collect();

            let return_type = self.soroban_to_ts_type(&func.return_type);

            output.push_str(&format!(
                "{}async {}({}): Promise<{}> {{\n",
                self.indent,
                func.name,
                params.join(", "),
                return_type
            ));

            // Method body
            output.push_str(&format!(
                "{}{}// TODO: Implement contract call\n",
                self.indent, self.indent
            ));
            output.push_str(&format!(
                "{}{}throw new Error('Not implemented');\n",
                self.indent, self.indent
            ));
            output.push_str(&format!("{}}}\n\n", self.indent));
        }

        output.push_str("}\n");
        output
    }

    /// Convert Soroban type to TypeScript type
    fn soroban_to_ts_type(&self, soroban_type: &SorobanType) -> String {
        match soroban_type {
            SorobanType::Bool => "boolean".to_string(),
            SorobanType::I32 => "number".to_string(),
            SorobanType::I64 => "bigint".to_string(),
            SorobanType::I128 => "bigint".to_string(),
            SorobanType::I256 => "bigint".to_string(),
            SorobanType::U32 => "number".to_string(),
            SorobanType::U64 => "bigint".to_string(),
            SorobanType::U128 => "bigint".to_string(),
            SorobanType::U256 => "bigint".to_string(),
            SorobanType::Symbol => "string".to_string(),
            SorobanType::String => "string".to_string(),
            SorobanType::Bytes => "Buffer".to_string(),
            SorobanType::BytesN { n } => format!("Buffer /* {} bytes */", n),
            SorobanType::Address => "string".to_string(),
            SorobanType::Void => "void".to_string(),
            SorobanType::Timepoint => "bigint".to_string(),
            SorobanType::Duration => "bigint".to_string(),
            SorobanType::Option { value_type } => {
                format!("{} | null", self.soroban_to_ts_type(value_type))
            }
            SorobanType::Result { ok_type, err_type } => {
                format!(
                    "{{ ok: {} }} | {{ err: {} }}",
                    self.soroban_to_ts_type(ok_type),
                    self.soroban_to_ts_type(err_type)
                )
            }
            SorobanType::Vec { element_type } => {
                format!("Array<{}>", self.soroban_to_ts_type(element_type))
            }
            SorobanType::Map { key_type, value_type } => {
                format!(
                    "Map<{}, {}>",
                    self.soroban_to_ts_type(key_type),
                    self.soroban_to_ts_type(value_type)
                )
            }
            SorobanType::Tuple { elements } => {
                let types: Vec<String> = elements.iter().map(|e| self.soroban_to_ts_type(e)).collect();
                format!("[{}]", types.join(", "))
            }
            SorobanType::Struct { name, .. } => name.clone(),
            SorobanType::Enum { name, .. } => name.clone(),
            SorobanType::Custom { name } => name.clone(),
        }
    }
}

impl Default for TypeScriptGenerator {
    fn default() -> Self {
        Self::new()
    }
}

/// Rust binding generator
pub struct RustGenerator {
    indent: String,
}

impl RustGenerator {
    pub fn new() -> Self {
        Self {
            indent: "    ".to_string(),
        }
    }

    /// Generate complete Rust bindings for a contract
    pub fn generate(&self, abi: &ContractABI) -> String {
        let mut output = String::new();

        // Header
        output.push_str("//! Auto-generated Rust bindings for ");
        output.push_str(&abi.name);
        output.push_str("\n//! Generated by Soroban Registry Type Safety Validator\n");
        output.push_str("//! DO NOT EDIT - Regenerate with `soroban-registry validate-call --generate-bindings`\n\n");

        // Imports
        output.push_str("use soroban_sdk::{Address, Bytes, BytesN, Env, String, Symbol, Vec, Map, contracttype};\n");
        output.push_str("use soroban_sdk::xdr::{ScVal, ToXdr, FromXdr};\n\n");

        // Generate custom types
        for (name, soroban_type) in &abi.types {
            output.push_str(&self.generate_type_definition(name, soroban_type));
            output.push('\n');
        }

        // Generate contract trait
        output.push_str(&self.generate_contract_trait(abi));

        // Generate contract client
        output.push_str(&self.generate_contract_client(abi));

        output
    }

    /// Generate Rust type definition
    fn generate_type_definition(&self, name: &str, soroban_type: &SorobanType) -> String {
        match soroban_type {
            SorobanType::Struct { fields, .. } => {
                let mut output = "#[contracttype]\n".to_string();
                output.push_str("#[derive(Clone, Debug, Eq, PartialEq)]\n");
                output.push_str(&format!("pub struct {} {{\n", name));
                for field in fields {
                    let rust_type = self.soroban_to_rust_type(&field.field_type);
                    if let Some(doc) = &field.doc {
                        output.push_str(&format!("{}/// {}\n", self.indent, doc));
                    }
                    output.push_str(&format!("{}pub {}: {},\n", self.indent, field.name, rust_type));
                }
                output.push_str("}\n");
                output
            }
            SorobanType::Enum { variants, .. } => {
                let mut output = "#[contracttype]\n".to_string();
                output.push_str("#[derive(Clone, Debug, Eq, PartialEq)]\n");
                output.push_str(&format!("pub enum {} {{\n", name));
                for variant in variants {
                    if let Some(doc) = &variant.doc {
                        output.push_str(&format!("{}/// {}\n", self.indent, doc));
                    }
                    if let Some(fields) = &variant.fields {
                        output.push_str(&format!("{}{} {{\n", self.indent, variant.name));
                        for field in fields {
                            let rust_type = self.soroban_to_rust_type(&field.field_type);
                            output.push_str(&format!(
                                "{}{}{}: {},\n",
                                self.indent, self.indent, field.name, rust_type
                            ));
                        }
                        output.push_str(&format!("{}}},\n", self.indent));
                    } else {
                        output.push_str(&format!("{}{},\n", self.indent, variant.name));
                    }
                }
                output.push_str("}\n");
                output
            }
            _ => format!(
                "pub type {} = {};\n",
                name,
                self.soroban_to_rust_type(soroban_type)
            ),
        }
    }

    /// Generate contract trait
    fn generate_contract_trait(&self, abi: &ContractABI) -> String {
        let mut output = format!("/// {} contract interface\n", abi.name);
        output.push_str(&format!("pub trait {} {{\n", abi.name));

        for func in &abi.functions {
            if func.visibility != FunctionVisibility::Public {
                continue;
            }

            // Doc comment
            if let Some(doc) = &func.doc {
                output.push_str(&format!("{}/// {}\n", self.indent, doc));
            }

            // Method signature
            let params: Vec<String> = func
                .params
                .iter()
                .map(|p| format!("{}: {}", p.name, self.soroban_to_rust_type(&p.param_type)))
                .collect();

            let return_type = self.soroban_to_rust_type(&func.return_type);

            output.push_str(&format!(
                "{}fn {}(&self, env: &Env{}) -> {};\n",
                self.indent,
                func.name,
                if params.is_empty() {
                    String::new()
                } else {
                    format!(", {}", params.join(", "))
                },
                return_type
            ));
        }

        output.push_str("}\n\n");
        output
    }

    /// Generate contract client
    fn generate_contract_client(&self, abi: &ContractABI) -> String {
        let mut output = format!(
            "/// Client for interacting with {} contract\n",
            abi.name
        );
        output.push_str(&format!("pub struct {}Client {{\n", abi.name));
        output.push_str(&format!("{}contract_id: Address,\n", self.indent));
        output.push_str("}\n\n");

        output.push_str(&format!("impl {}Client {{\n", abi.name));

        // Constructor
        output.push_str(&format!(
            "{}pub fn new(contract_id: Address) -> Self {{\n",
            self.indent
        ));
        output.push_str(&format!(
            "{}{}Self {{ contract_id }}\n",
            self.indent, self.indent
        ));
        output.push_str(&format!("{}}}\n\n", self.indent));

        // Methods
        for func in &abi.functions {
            if func.visibility != FunctionVisibility::Public {
                continue;
            }

            if let Some(doc) = &func.doc {
                output.push_str(&format!("{}/// {}\n", self.indent, doc));
            }

            let params: Vec<String> = func
                .params
                .iter()
                .map(|p| format!("{}: {}", p.name, self.soroban_to_rust_type(&p.param_type)))
                .collect();

            let return_type = self.soroban_to_rust_type(&func.return_type);

            output.push_str(&format!(
                "{}pub fn {}(&self, env: &Env{}) -> {} {{\n",
                self.indent,
                func.name,
                if params.is_empty() {
                    String::new()
                } else {
                    format!(", {}", params.join(", "))
                },
                return_type
            ));

            // Method body - invoke contract
            output.push_str(&format!(
                "{}{}env.invoke_contract(\n",
                self.indent, self.indent
            ));
            output.push_str(&format!(
                "{}{}{}{}self.contract_id.clone(),\n",
                self.indent, self.indent, self.indent, self.indent
            ));
            output.push_str(&format!(
                "{}{}{}{}Symbol::new(env, \"{}\"),\n",
                self.indent, self.indent, self.indent, self.indent, func.name
            ));

            // Build args
            let param_names: Vec<&str> = func.params.iter().map(|p| p.name.as_str()).collect();
            if param_names.is_empty() {
                output.push_str(&format!(
                    "{}{}{}{}Vec::new(env),\n",
                    self.indent, self.indent, self.indent, self.indent
                ));
            } else {
                output.push_str(&format!(
                    "{}{}{}{}({},).into_val(env),\n",
                    self.indent,
                    self.indent,
                    self.indent,
                    self.indent,
                    param_names.join(", ")
                ));
            }

            output.push_str(&format!("{}{})\n", self.indent, self.indent));
            output.push_str(&format!("{}}}\n\n", self.indent));
        }

        output.push_str("}\n");
        output
    }

    /// Convert Soroban type to Rust type
    fn soroban_to_rust_type(&self, soroban_type: &SorobanType) -> String {
        match soroban_type {
            SorobanType::Bool => "bool".to_string(),
            SorobanType::I32 => "i32".to_string(),
            SorobanType::I64 => "i64".to_string(),
            SorobanType::I128 => "i128".to_string(),
            SorobanType::I256 => "soroban_sdk::I256".to_string(),
            SorobanType::U32 => "u32".to_string(),
            SorobanType::U64 => "u64".to_string(),
            SorobanType::U128 => "u128".to_string(),
            SorobanType::U256 => "soroban_sdk::U256".to_string(),
            SorobanType::Symbol => "Symbol".to_string(),
            SorobanType::String => "String".to_string(),
            SorobanType::Bytes => "Bytes".to_string(),
            SorobanType::BytesN { n } => format!("BytesN<{}>", n),
            SorobanType::Address => "Address".to_string(),
            SorobanType::Void => "()".to_string(),
            SorobanType::Timepoint => "u64".to_string(),
            SorobanType::Duration => "u64".to_string(),
            SorobanType::Option { value_type } => {
                format!("Option<{}>", self.soroban_to_rust_type(value_type))
            }
            SorobanType::Result { ok_type, err_type } => {
                format!(
                    "Result<{}, {}>",
                    self.soroban_to_rust_type(ok_type),
                    self.soroban_to_rust_type(err_type)
                )
            }
            SorobanType::Vec { element_type } => {
                format!("Vec<{}>", self.soroban_to_rust_type(element_type))
            }
            SorobanType::Map { key_type, value_type } => {
                format!(
                    "Map<{}, {}>",
                    self.soroban_to_rust_type(key_type),
                    self.soroban_to_rust_type(value_type)
                )
            }
            SorobanType::Tuple { elements } => {
                let types: Vec<String> = elements.iter().map(|e| self.soroban_to_rust_type(e)).collect();
                format!("({})", types.join(", "))
            }
            SorobanType::Struct { name, .. } => name.clone(),
            SorobanType::Enum { name, .. } => name.clone(),
            SorobanType::Custom { name } => name.clone(),
        }
    }
}

impl Default for RustGenerator {
    fn default() -> Self {
        Self::new()
    }
}

/// Generate bindings in the specified language
pub fn generate_bindings(abi: &ContractABI, language: BindingLanguage) -> String {
    match language {
        BindingLanguage::TypeScript => TypeScriptGenerator::new().generate(abi),
        BindingLanguage::Rust => RustGenerator::new().generate(abi),
    }
}

/// Supported binding languages
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BindingLanguage {
    TypeScript,
    Rust,
}

impl std::str::FromStr for BindingLanguage {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "typescript" | "ts" => Ok(BindingLanguage::TypeScript),
            "rust" | "rs" => Ok(BindingLanguage::Rust),
            _ => Err(format!("Unknown language: {}. Use 'typescript' or 'rust'", s)),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_abi() -> ContractABI {
        let mut abi = ContractABI::new("TestToken".to_string());

        abi.functions.push(ContractFunction {
            name: "transfer".to_string(),
            visibility: FunctionVisibility::Public,
            params: vec![
                FunctionParam {
                    name: "to".to_string(),
                    param_type: SorobanType::Address,
                    doc: Some("Recipient address".to_string()),
                },
                FunctionParam {
                    name: "amount".to_string(),
                    param_type: SorobanType::I128,
                    doc: Some("Amount to transfer".to_string()),
                },
            ],
            return_type: SorobanType::Bool,
            doc: Some("Transfer tokens to another address".to_string()),
            is_mutable: true,
        });

        abi.functions.push(ContractFunction {
            name: "balance".to_string(),
            visibility: FunctionVisibility::Public,
            params: vec![FunctionParam {
                name: "address".to_string(),
                param_type: SorobanType::Address,
                doc: Some("Address to query".to_string()),
            }],
            return_type: SorobanType::I128,
            doc: Some("Get token balance".to_string()),
            is_mutable: false,
        });

        abi
    }

    #[test]
    fn test_typescript_generation() {
        let abi = create_test_abi();
        let ts = TypeScriptGenerator::new().generate(&abi);

        assert!(ts.contains("interface ITestToken"));
        assert!(ts.contains("transfer(to: string, amount: bigint): Promise<boolean>"));
        assert!(ts.contains("balance(address: string): Promise<bigint>"));
        assert!(ts.contains("class TestTokenClient"));
    }

    #[test]
    fn test_rust_generation() {
        let abi = create_test_abi();
        let rust = RustGenerator::new().generate(&abi);

        assert!(rust.contains("pub trait TestToken"));
        assert!(rust.contains("fn transfer(&self, env: &Env, to: Address, amount: i128) -> bool"));
        assert!(rust.contains("fn balance(&self, env: &Env, address: Address) -> i128"));
        assert!(rust.contains("pub struct TestTokenClient"));
    }

    #[test]
    fn test_binding_language_parse() {
        assert_eq!(
            "typescript".parse::<BindingLanguage>().unwrap(),
            BindingLanguage::TypeScript
        );
        assert_eq!(
            "ts".parse::<BindingLanguage>().unwrap(),
            BindingLanguage::TypeScript
        );
        assert_eq!(
            "rust".parse::<BindingLanguage>().unwrap(),
            BindingLanguage::Rust
        );
        assert_eq!(
            "rs".parse::<BindingLanguage>().unwrap(),
            BindingLanguage::Rust
        );
    }
}
